; generated by lcc-xr18CX $Version: 5.0 - XR18CX $ on Sat Jun 20 08:36:20 2020

SP:	equ	2 ;stack pointer
memAddr: equ	14
retAddr: equ	6
retVal:	equ	15
regArg1: equ	12
regArg2: equ	13
	listing off
	include lcc1802proloCX.inc
	listing on
	orgd
_starship:
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 123
	db 222
	db 219
	db 222
	db 0
	db 0
	db 0
	db 0
	db 74
	db 80
	db 218
	db 82
	db 0
	db 0
	db 0
	db 0
	db 66
	db 94
	db 171
	db 208
	db 0
	db 0
	db 0
	db 0
	db 74
	db 66
	db 138
	db 82
	db 0
	db 0
	db 0
	db 0
	db 123
	db 222
	db 138
	db 94
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 7
	db 224
	db 0
	db 0
	db 0
	db 0
	db 255
	db 255
	db 255
	db 255
	db 0
	db 6
	db 0
	db 1
	db 0
	db 0
	db 0
	db 1
	db 0
	db 127
	db 224
	db 1
	db 0
	db 0
	db 0
	db 2
	db 127
	db 192
	db 63
	db 224
	db 252
	db 255
	db 255
	db 254
	db 64
	db 15
	db 0
	db 16
	db 4
	db 128
	db 0
	db 0
	db 127
	db 192
	db 63
	db 224
	db 4
	db 128
	db 0
	db 0
	db 0
	db 63
	db 208
	db 64
	db 4
	db 128
	db 0
	db 0
	db 0
	db 15
	db 8
	db 32
	db 4
	db 128
	db 122
	db 30
	db 0
	db 0
	db 7
	db 144
	db 4
	db 128
	db 66
	db 16
	db 0
	db 0
	db 24
	db 127
	db 252
	db 240
	db 114
	db 28
	db 0
	db 0
	db 48
	db 0
	db 0
	db 16
	db 66
	db 16
	db 0
	db 0
	db 115
	db 252
	db 0
	db 16
	db 123
	db 208
	db 0
	db 0
	db 48
	db 0
	db 63
	db 240
	db 0
	db 0
	db 0
	db 0
	db 24
	db 15
	db 192
	db 0
	db 0
	db 0
	db 0
	db 0
	db 7
	db 240
	db 0
	db 0
	db 0
	db 0
_PIN4:
	db 0
	orgc
;$$function_start$$:_startpixie=void function(void)
_startpixie:		;framesize=6
	reserve 4
;void startpixie(){
;	asm(" ldaD R1,DisplayInt\n");
;	(void)inp(1);
 ldaD R1,DisplayInt
	ldaD R12,1; reg:acon
	Ccall _inp; CALLI2(ar)
;}
L1:
	release 4
	Cretn

;$$function_end$$ _startpixie
;$$function_start$$:_display=void function(pointer to char,unsigned int)
_display:		;framesize=2
;void display(char * what, unsigned int where){//where is encoded as hex yyxx for row and column in pixels
;	asm(" cpy2 RF,R12\n"
 cpy2 RF,R12
 cpy2 RE,R13
 ccall DrawString
;}
L3:
	Cretn

;$$function_end$$ _display
;$$function_start$$:_disprc=void function(pointer to char,unsigned char,unsigned char)
_disprc:		;framesize=8
	reserve 6
	st2 R12,'O',sp,(8+1); flag1 
	st2 R13,'O',sp,(10+1); flag1 
	ldA2 R11,'O',sp,(10+1); reg:addr
	ld2 R10,'O',sp,(10+1) ;reg:INDIRI2(addr)
	str1 R10,R11; ASGNU1(indaddr,LOADU1(LOADU2(reg))) 18-03-21
	ldA2 R11,'O',sp,(12+1); reg:addr
	ld2 R10,'O',sp,(12+1) ;reg:INDIRI2(addr)
	str1 R10,R11; ASGNU1(indaddr,LOADU1(LOADU2(reg))) 18-03-21
;void disprc(char * what, unsigned char row, unsigned char col){//row and char are pixel coordinates
;	unsigned int where=(row<<8)+col;
	ld1 R11,'O',sp,(10+1)
	zExt R11 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
	shl2I R11,8
	ld1 R10,'O',sp,(12+1)
	zExt R10 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
	alu2 R11,R11,R10,add,adc; ADDI2(r,r)
	st2 R11,'O',sp,(4+1); ASGNU2(addr,LOADU2(reg)) 18-02-26
;	display(what,where);
	ld2 R12,'O',sp,(8+1) ;reg:INDIRP2(addr)
	ld2 R13,'O',sp,(4+1) ;reg:INDIRU2(addr)
	Ccall _display
;}
L5:
	release 6
	Cretn

;$$function_end$$ _disprc
;$$function_start$$:_clear=void function(void)
_clear:		;framesize=2
;void clear(){
;	asm(" ld2z RF\n");
;	asm(" ccall FillScreen\n");
 ld2z RF
 ccall FillScreen
;}
L6:
	Cretn

;$$function_end$$ _clear
;$$function_start$$:_main=int function(void)
_main:		;framesize=16
	reserve 4; save room for local variables
	pushr R6
	pushr R7
	reserve 6; save room for outgoing arguments
;int main(){
;	unsigned char row=0, col=0; //row and column positions for drawing
	ldaD R7,0; reg:acon
	ldaD R6,0; reg:acon
;	int rdir=6, cdir=3; //direction of motion
	st2I 6,'O',sp,(12+1); ASGNI2(addr,acon)
	st2I 3,'O',sp,(10+1); ASGNI2(addr,acon)
;	startpixie();
	Ccall _startpixie
	lbr L11
L10:
;	while(1){
;		disprc(" ",row,col);
	ldaD R12,L13; reg:acon
	cpy1 R13,R7
	zExt R13 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
	cpy1 R11,R6
	zExt R11 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
	st2 R11,'O',sp,(4+1); arg+f**
	Ccall _disprc
;		if (row>58){
	cpy1 R11,R7
	zExt R11 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
	jnI2I R11,58,lbdf,L14 ;LEI2 58 11 L14; LE is flipped test & subtraction
;			rdir=-6;
	st2I -6,'O',sp,(12+1); ASGNI2(addr,acon)
;		} else if (row<6){
	lbr L15
L14:
	cpy1 R11,R7
	zExt R11 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
	jcI2I R11,6,lbdf,L16; GE is flipped test from LT
;			rdir=6;
	st2I 6,'O',sp,(12+1); ASGNI2(addr,acon)
;		}
L16:
L15:
;		if (col>58){
	cpy1 R11,R6
	zExt R11 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
	jnI2I R11,58,lbdf,L18 ;LEI2 58 11 L18; LE is flipped test & subtraction
;			cdir=-6;
	st2I -6,'O',sp,(10+1); ASGNI2(addr,acon)
;		} else if (col<6){
	lbr L19
L18:
	cpy1 R11,R6
	zExt R11 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
	jcI2I R11,6,lbdf,L20; GE is flipped test from LT
;			cdir=6;
	st2I 6,'O',sp,(10+1); ASGNI2(addr,acon)
;		}
L20:
L19:
;		row+=rdir;col+=cdir;
	cpy1 R11,R7
	zExt R11 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
	alu2RRS R11,R11,'O',sp,(12+1),add,adc; ADDI2(r,INDIRI2(addr))	DH3
	cpy1 R7,R11;LOADU1(reg)
	cpy1 R11,R6
	zExt R11 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
	alu2RRS R11,R11,'O',sp,(10+1),add,adc; ADDI2(r,INDIRI2(addr))	DH3
	cpy1 R6,R11;LOADU1(reg)
;		disprc("O",row,col);
	ldaD R12,L22; reg:acon
	cpy1 R13,R7
	zExt R13 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
	cpy1 R11,R6
	zExt R11 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
	st2 R11,'O',sp,(4+1); arg+f**
	Ccall _disprc
;		delay(100);
	ldaD R12,100; reg:acon
	Ccall _delay
;	}
L11:
;	while(1){
	lbr L10
;	return 0;
	ld2z R15; reg:con0
L9:
	release 6; release room for outgoing arguments
	popr R7
	popr R6
	release 4; release room for local variables 
	Cretn

;$$function_end$$ _main
;$$function_start$$:_includepixie=void function(void)
_includepixie:		;framesize=2
;void includepixie(){
;	asm(" INCLUDE bitfuncs.inc\n");
;	asm(" include nStdDefs.inc\n");
;	asm("System				EQU \"Elf\"\n");
;	asm("UseIO				EQU \"TRUE\"\n");
;	asm("UseRandom			EQU \"TRUE\"\n");
;	asm("RandomSize			EQU 8				; 8 or 16\n");
;	asm("UseGraphics			EQU \"TRUE\"\n");
;	asm("Resolution			EQU \"64x64\"			; 64x32, 64x64 or 64x128\n");
;	asm("BackBuffer			EQU \"OFF\"			; 'OFF', 'COPY' or 'SWAP'\n");
;	asm("UseText				EQU \"TRUE\"\n");
;	asm("Use96Char			EQU \"TRUE\"			; TRUE = 96 char, FALSE = 64 char\n");
;	asm("UseConsole			EQU \"FALSE\"\n");
;	asm("UseConversion		EQU \"TRUE\"\n");
;	asm(" align 256\n");
;	asm(" INCLUDE Graphics1861.asm\n");
;	asm(" INCLUDE Conversion.asm\n");
;	asm(" align 256\n");
;	asm(" INCLUDE Text1861.asm\n");
 INCLUDE bitfuncs.inc
 include nStdDefs.inc
System				EQU "Elf"
UseIO				EQU "TRUE"
UseRandom			EQU "TRUE"
RandomSize			EQU 8				; 8 or 16
UseGraphics			EQU "TRUE"
Resolution			EQU "64x64"			; 64x32, 64x64 or 64x128
BackBuffer			EQU "OFF"			; 'OFF', 'COPY' or 'SWAP'
UseText				EQU "TRUE"
Use96Char			EQU "TRUE"			; TRUE = 96 char, FALSE = 64 char
UseConsole			EQU "FALSE"
UseConversion		EQU "TRUE"
 align 256
 INCLUDE Graphics1861.asm
 INCLUDE Conversion.asm
 align 256
 INCLUDE Text1861.asm
;}
L23:
	Cretn

;$$function_end$$ _includepixie
;$$function_start$$:_strncmp=int function(pointer to const char,pointer to const char,unsigned int)
_strncmp:		;framesize=6
	pushr R6
	pushr R7
	ld2 R7,'O',sp,(10+1) ;reg:INDIRU2(addr)
;{
;    for ( ; n > 0; s1++, s2++, --n)
	lbr L46
L43:
;	if (*s1 != *s2)
	ldn1 R11,R12;reg:  INDIRU1(indaddr)
	zExt R11 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
	ldn1 R10,R13;reg:  INDIRU1(indaddr)
	zExt R10 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
	jeqI2 R11,R10,L47; EQI2(reg,reg)
;	    return ((*(unsigned char *)s1 < *(unsigned char *)s2) ? -1 : +1);
	ldn1 R11,R12;reg:  INDIRU1(indaddr)
	zExt R11 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
	ldn1 R10,R13;reg:  INDIRU1(indaddr)
	zExt R10 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
	jcI2 R11,R10,lbdf,L50; GE is flipped test from LT
	ldaD R6,-1; reg:acon
	lbr L51
L50:
	ldaD R6,1; reg:acon
L51:
	cpy2 R15,R6 ;LOADI2(reg)
	lbr L42
L47:
;	else if (*s1 == '\0')
	ldn1 R11,R12;reg:  INDIRU1(indaddr)
	jnzU1 R11,L52; NEI2(CVUI2(reg),con0)
;	    return 0;
	ld2z R15; reg:con0
	lbr L42
L52:
L44:
;    for ( ; n > 0; s1++, s2++, --n)
	incm R12,1
	incm R13,1
	decm R7,1	;SUBU2(reg,consm)
L46:
	jnzU2 R7,L43; NE 0 
;    return 0;
	ld2z R15; reg:con0
L42:
	popr R7
	popr R6
	Cretn

;$$function_end$$ _strncmp
;$$function_start$$:_strlen=unsigned int function(pointer to char)
_strlen:		;framesize=4
	pushr R7
;{
;	unsigned int slen = 0 ;
	ld2z R7; reg:con0
	lbr L56
L55:
;	while (*str != 0) {
;      slen++ ;
	incm R7,1
;      str++ ;
	incm R12,1
;   }
L56:
;	while (*str != 0) {
	ldn1 R11,R12;reg:  INDIRU1(indaddr)
	jnzU1 R11,L55; NEI2(CVUI2(reg),con0)
;   return slen;
	cpy2 R15,R7 ;LOADU2*(reg)
L54:
	popr R7
	Cretn

;$$function_end$$ _strlen
;$$function_start$$:_printstr=void function(pointer to char)
_printstr:		;framesize=8
	pushr R7
	reserve 4; save room for outgoing arguments
	cpy2 R7,R12; function(2055) 1
;void printstr(char *ptr){
	lbr L60
L59:
;    while(*ptr){
;		putc(*ptr++); //jan 29
	cpy2 R11,R7 ;LOADP2(reg)
	cpy2 R7,R11
	incm R7,1
	ldn1 R11,R11;reg:  INDIRU1(indaddr)
	cpy1 R12,R11
	zExt R12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
	Ccall _putc
;		asm(" nop1806\n nop1806\n nop1806\n"); //17-03-09
 nop1806
 nop1806
 nop1806
;	}
L60:
;    while(*ptr){
	ldn1 R11,R7;reg:  INDIRU1(indaddr)
	jnzU1 R11,L59; NEI2(CVUI2(reg),con0)
;}
L58:
	release 4; release room for outgoing arguments
	popr R7
	Cretn

;$$function_end$$ _printstr
	orgc
	align 4
_round_nums:
	dd 0x3f000000
	dd 0x3d4ccccd
	dd 0x3ba3d70a
	dd 0x3a03126f
	dd 0x3851b717
	dd 0x36a7c5ac
	dd 0x350637bd
	dd 0x3356bf95
	align 4
_mult_nums:
	dd 0x3f800000
	dd 0x41200000
	dd 0x42c80000
	dd 0x447a0000
	dd 0x461c4000
	dd 0x47c35000
	dd 0x49742400
	dd 0x4b189680
	orgc
;$$function_start$$:_ftoa=pointer to char function(float,pointer to char,unsigned int)
_ftoa:		;framesize=76
	reserve 62; save room for local variables
	pushr R6
	pushr R7
	reserve 8; save room for outgoing arguments
	cpy4 RL6,RL12; halfbaked&floaty
;{
;   char *output = outbfr ;
	ld2 R11,'O',sp,(80+1) ;reg:INDIRP2(addr)
	st2 R11,'O',sp,(72+1); ASGNP2(addr,reg)
;   if (flt < 0.0) {
	ld4 RL10,'D',(L66),0;INDIRF4(addr)
	jcF4 RL6,RL10,lbdf,L64;GEF4(reg,reg) - reverse test
;      *output++ = '-' ;
	ld2 R11,'O',sp,(72+1) ;reg:INDIRP2(addr)
	cpy2 R10,R11
	incm R10,1
	st2 R10,'O',sp,(72+1); ASGNP2(addr,reg)
	str1I 45,R11; ASGNU1(indaddr,acon)	DH
;      flt *= -1.0 ;
	ld4 RL8,'D',(L67),0;INDIRF4(addr)
	cpy4 RL10,RL6; LOADU4(reg)
	Ccall fp_mul ;MULF4(reg,reg)
	cpy4 RL6,RL8; LOADU4(reg)
;   } else {
	lbr L65
L64:
;      if (use_leading_plus) {
	lbr L68
;         *output++ = '+' ;
	ld2 R11,'O',sp,(72+1) ;reg:INDIRP2(addr)
	cpy2 R10,R11
	incm R10,1
	st2 R10,'O',sp,(72+1); ASGNP2(addr,reg)
	str1I 43,R11; ASGNU1(indaddr,acon)	DH
;      }
L68:
;   }
L65:
;   if (dec_digits < 8) {
	ld2 R11,'O',sp,(82+1) ;reg:INDIRU2(addr)
	jcI2I R11,8,lbdf,L70; GE is flipped test from LT
;      flt += round_nums[dec_digits] ;
	cpy4 RL8,RL6; LOADU4(reg)
	ld2 R11,'O',sp,(82+1) ;reg:INDIRU2(addr)
	shl2I R11,2
	ld4 RL10,'O',R11,(_round_nums);INDIRF4(addr)
	Ccall fp_add ;ADDF4(reg,reg)
	cpy4 RL6,RL8; LOADU4(reg)
;   }
L70:
;	mult=mult_nums[dec_digits];
	ld2 R11,'O',sp,(82+1) ;reg:INDIRU2(addr)
	shl2I R11,2
	ld4 RL10,'O',R11,(_mult_nums);INDIRF4(addr)
	st4 RL10,'O',sp,(64+1); ASGNF4(addr,reg)
;   wholeNum = flt;
	cpy4 RL8,RL6; LOADU4(reg)
	ccall cvfi4; CVFI4(reg) convert float to long
	st4 RL8,'O',sp,(68+1)
;   decimalNum = ((flt - wholeNum) * mult);
	cpy4 RL8,RL6; LOADU4(reg)
	st4 RL8,'O',sp,(12+1); ASGNF4(addr,reg)
	ld4 RL8,'O',sp,(68+1);reg:  INDIRI4(addr)
	Ccall cvif4; emit2
	cpy4 RL10,RL8; LOADU4(reg)
	ld4 RL8,'O',sp,(12+1);INDIRF4(addr)
	Ccall fp_sub ;SUBF4(reg,reg)
	ld4 RL10,'O',sp,(64+1);INDIRF4(addr)
	Ccall fp_mul ;MULF4(reg,reg)
	ccall cvfi4; CVFI4(reg) convert float to long
	st4 RL8,'O',sp,(60+1)
;   strcpy(output,dubdabx(wholeNum,output,1));
	ld4 Rp1p2,'O',sp,(68+1);reg:  INDIRI4(addr)
	ld2 R11,'O',sp,(72+1) ;reg:INDIRP2(addr)
	st2 R11,'O',sp,(4+1); arg+f**
	ldaD R11,1; reg:acon
	st2 R11,'O',sp,(6+1); arg+f**
	Ccall _dubdabx
	cpy2 R11,R15 ;LOADP2(reg)
	ld2 R12,'O',sp,(72+1) ;reg:INDIRP2(addr)
	cpy2 R13,R11 ;LOADP2(reg)
	Ccall _strcpy
;   output+=strlen(output);
	ld2 R12,'O',sp,(72+1) ;reg:INDIRP2(addr)
	Ccall _strlen;CALLU2(ar)*
	alu2RRS R11,R15,'O',sp,(72+1),add,adc; ADDI2(r,INDIRP2(addr))	DH3.1
	st2 R11,'O',sp,(72+1); ASGNP2(addr,reg)
;   if (dec_digits > 0) {
	ld2 R11,'O',sp,(82+1) ;reg:INDIRU2(addr)
	jzU2 R11,L72; EQ U 0
;		*output++ = '.' ;
	ld2 R11,'O',sp,(72+1) ;reg:INDIRP2(addr)
	cpy2 R10,R11
	incm R10,1
	st2 R10,'O',sp,(72+1); ASGNP2(addr,reg)
	str1I 46,R11; ASGNU1(indaddr,acon)	DH
;		strcpy(output,dubdabx(decimalNum,output,dec_digits));
	ld4 Rp1p2,'O',sp,(60+1);reg:  INDIRI4(addr)
	ld2 R11,'O',sp,(72+1) ;reg:INDIRP2(addr)
	st2 R11,'O',sp,(4+1); arg+f**
	ld2 R11,'O',sp,(82+1) ;reg:INDIRU2(addr)
	st2 R11,'O',sp,(6+1); arg+f**
	Ccall _dubdabx
	cpy2 R11,R15 ;LOADP2(reg)
	ld2 R12,'O',sp,(72+1) ;reg:INDIRP2(addr)
	cpy2 R13,R11 ;LOADP2(reg)
	Ccall _strcpy
;	}
L72:
;   return outbfr;
	ld2 R15,'O',sp,(80+1) ;reg:INDIRP2(addr)
L63:
	release 8; release room for outgoing arguments
	popr R7
	popr R6
	release 62; release room for local variables 
	Cretn

;$$function_end$$ _ftoa
;$$function_start$$:_itoa=pointer to char function(int,pointer to char)
_itoa:		;framesize=16
	reserve 6; save room for local variables
	pushr R6
	pushr R7
	reserve 4; save room for outgoing arguments
	st2 R12,'O',sp,(16+1); flag1 
	st2 R13,'O',sp,(18+1); flag1 
;char * itoa(int s, char *buffer){ //convert an integer to printable ascii in a buffer supplied by the caller
;	unsigned int flag=0;
	ld2z R11; reg:con0
	st2 R11,'O',sp,(10+1); ASGNU2(addr,reg)
;	char * bptr; bptr=buffer;
	ld2 R11,'O',sp,(18+1) ;reg:INDIRP2(addr)
	st2 R11,'O',sp,(8+1); ASGNP2(addr,reg)
;	if (s<0){
	ld2 R11,'O',sp,(16+1) ;reg:INDIRI2(addr)
	jcI2I R11,0,lbdf,L75; GE is flipped test from LT
;		*bptr='-';bptr++;
	ld2 R11,'O',sp,(8+1) ;reg:INDIRP2(addr)
	str1I 45,R11; ASGNU1(indaddr,acon)	DH
	ld2 R11,'O',sp,(8+1) ;reg:INDIRP2(addr)
	incm R11,1
	st2 R11,'O',sp,(8+1); ASGNP2(addr,reg)
;		n=-s;
	ld2 R11,'O',sp,(16+1) ;reg:INDIRI2(addr)
	negI2 R11,R11 ;was alu2I R11,R11,0,sdi,sdbi
	cpy2 R6,R11 ;LOADU2*(reg)
;	} else{
	lbr L76
L75:
;		n=s;
	ld2 R11,'O',sp,(16+1) ;reg:INDIRI2(addr)
	cpy2 R6,R11 ;LOADU2*(reg)
;	}
L76:
;	k=10000;
	ldaD R7,10000; reg:acon
	lbr L78
L77:
;	while(k>0){
;		for(r=0;k<=n;r++,n-=k); // was r=n/k
	ld2z R11; reg:con0
	st2 R11,'O',sp,(12+1); ASGNU2(addr,reg)
	lbr L83
L80:
L81:
	ld2 R11,'O',sp,(12+1) ;reg:INDIRU2(addr)
	incm R11,1
	st2 R11,'O',sp,(12+1); ASGNU2(addr,reg)
	alu2 R6,R6,R7,sm,smb
L83:
	jcU2 R6,R7,lbdf,L80 ;LE is flipped test & operands
;		if (flag || r>0||k==1){
	ld2 R11,'O',sp,(10+1) ;reg:INDIRU2(addr)
	jnzU2 R11,L87; NE 0 
	ld2 R11,'O',sp,(12+1) ;reg:INDIRU2(addr)
	jnzU2 R11,L87; NE 0 
	jneU2I R7,1,L84; NE
L87:
;			*bptr=('0'+r);bptr++;
	ld2 R11,'O',sp,(8+1) ;reg:INDIRP2(addr)
	ld2 R10,'O',sp,(12+1) ;reg:INDIRU2(addr)
	ldA2 R10,'O',R10,(48); reg:addr
	str1 R10,R11; ASGNU1(indaddr,reg)		DH*
	ld2 R11,'O',sp,(8+1) ;reg:INDIRP2(addr)
	incm R11,1
	st2 R11,'O',sp,(8+1); ASGNP2(addr,reg)
;			flag='y';
	ldaD R11,121; reg:acon
	st2 R11,'O',sp,(10+1); ASGNU2(addr,reg)
;		}
L84:
;		k=k/10;
	cpy2 R12,R7 ;LOADU2*(reg)
	ldaD R13,10; reg:acon
	Ccall _divu2
	cpy2 R7,R15 ;LOADU2*(reg)
;	}
L78:
;	while(k>0){
	jnzU2 R7,L77; NE 0 
;	*bptr='\0';
	ld2 R11,'O',sp,(8+1) ;reg:INDIRP2(addr)
	str1I 0,R11; ASGNU1(indaddr,acon)	DH
;	return buffer;
	ld2 R15,'O',sp,(18+1) ;reg:INDIRP2(addr)
L74:
	release 4; release room for outgoing arguments
	popr R7
	popr R6
	release 6; release room for local variables 
	Cretn

;$$function_end$$ _itoa
;$$function_start$$:_ltoa=pointer to char function(long int,pointer to char)
_ltoa:		;framesize=16
	reserve 2; save room for local variables
	pushr R6
	pushr R7
	reserve 8; save room for outgoing arguments
	cpy4 RL6,RL12; halfbaked
;char * ltoa(long s, char *buffer){ //convert a long integer to printable ascii in a buffer supplied by the caller
;	char* bptr=buffer;
	ld2 R11,'O',sp,(20+1) ;reg:INDIRP2(addr)
	st2 R11,'O',sp,(12+1); ASGNP2(addr,reg)
;	if (s<0){
	ldI4 RL10,0 ;loading a long integer constant
	jcI4 RL6,RL10,lbdf,L89; GE is flipped test from LT
;		*bptr++='-';
	ld2 R11,'O',sp,(12+1) ;reg:INDIRP2(addr)
	cpy2 R10,R11
	incm R10,1
	st2 R10,'O',sp,(12+1); ASGNP2(addr,reg)
	str1I 45,R11; ASGNU1(indaddr,acon)	DH
;		s=-s;
	negI4 RL6,RL6 ;was alu4I RL6,RL6,0,sdi,sdbi
;	}
L89:
;	strcpy(bptr,dubdabx(s,bptr,1)); //uses assembler double-dabble routine
	cpy4 Rp1p2,RL6; LOADI4*
	ld2 R11,'O',sp,(12+1) ;reg:INDIRP2(addr)
	st2 R11,'O',sp,(4+1); arg+f**
	ldaD R11,1; reg:acon
	st2 R11,'O',sp,(6+1); arg+f**
	Ccall _dubdabx
	cpy2 R11,R15 ;LOADP2(reg)
	ld2 R12,'O',sp,(12+1) ;reg:INDIRP2(addr)
	cpy2 R13,R11 ;LOADP2(reg)
	Ccall _strcpy
;	return buffer;
	ld2 R15,'O',sp,(20+1) ;reg:INDIRP2(addr)
L88:
	release 8; release room for outgoing arguments
	popr R7
	popr R6
	release 2; release room for local variables 
	Cretn

;$$function_end$$ _ltoa
;$$function_start$$:_printint=void function(int)
_printint:		;framesize=14
	reserve 12
	st2 R12,'O',sp,(14+1); flag1 
;void printint(int s){ //print an integer
;	itoa(s,buffer);
	ld2 R12,'O',sp,(14+1) ;reg:INDIRI2(addr)
	ldA2 R13,'O',sp,(4+1); reg:addr
	Ccall _itoa
;	printstr(buffer);
	ldA2 R12,'O',sp,(4+1); reg:addr
	Ccall _printstr
;}
L91:
	release 12
	Cretn

;$$function_end$$ _printint
;$$function_start$$:_printlint=void function(long int)
_printlint:		;framesize=20
	reserve 18
	st2 R12,'O',sp,(20+1); flag1 
	st2 R13,'O',sp,(22+1); flag1 
;void printlint(long s){ //print a long integer
;	printstr(ltoa(s,buffer));
	ld4 Rp1p2,'O',sp,(20+1);reg:  INDIRI4(addr)
	ldA2 R11,'O',sp,(6+1); reg:addr
	st2 R11,'O',sp,(4+1); arg+f**
	Ccall _ltoa
	cpy2 R11,R15 ;LOADP2(reg)
	cpy2 R12,R11 ;LOADP2(reg)
	Ccall _printstr
;}
L92:
	release 18
	Cretn

;$$function_end$$ _printlint
;$$function_start$$:_printflt=void function(float)
_printflt:		;framesize=30
	reserve 28
	st2 R12,'O',sp,(30+1); flag1 
	st2 R13,'O',sp,(32+1); flag1 
;void printflt(float s){ //print a float
;	printstr(ftoa(s,buffer,3));
	ld4 Rp1p2,'O',sp,(30+1);INDIRF4(addr)
	ldA2 R11,'O',sp,(8+1); reg:addr
	st2 R11,'O',sp,(4+1); arg+f**
	ldaD R11,3; reg:acon
	st2 R11,'O',sp,(6+1); arg+f**
	Ccall _ftoa
	cpy2 R11,R15 ;LOADP2(reg)
	cpy2 R12,R11 ;LOADP2(reg)
	Ccall _printstr
;}
L93:
	release 28
	Cretn

;$$function_end$$ _printflt
;$$function_start$$:_putxn=void function(unsigned char)
_putxn:		;framesize=6
	reserve 4
	st2 R12,'O',sp,(6+1); flag1 
	ldA2 R11,'O',sp,(6+1); reg:addr
	ld2 R10,'O',sp,(6+1) ;reg:INDIRI2(addr)
	str1 R10,R11; ASGNU1(indaddr,LOADU1(LOADU2(reg))) 18-03-21
;void putxn(unsigned char x){ //print a nibble as ascii hex
;	if (x<10){
	ld1 R11,'O',sp,(6+1)
	zExt R11 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
	jcI2I R11,10,lbdf,L95; GE is flipped test from LT
;		putc(x+'0');
	ld1 R11,'O',sp,(6+1)
	zExt R11 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
	ldA2 R11,'O',R11,(48); reg:addr
	cpy1 R12,R11
	zExt R12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
	Ccall _putc
;	} else {
	lbr L96
L95:
;		putc(x+'A'-10);
	ld1 R11,'O',sp,(6+1)
	zExt R11 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
	ldA2 R11,'O',R11,(65); reg:addr
	alu2I R11,R11,10,smi,smbi
	cpy1 R12,R11
	zExt R12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
	Ccall _putc
;	}
L96:
;}
L94:
	release 4
	Cretn

;$$function_end$$ _putxn
;$$function_start$$:_putx=void function(unsigned char)
_putx:		;framesize=6
	reserve 4
	st2 R12,'O',sp,(6+1); flag1 
	ldA2 R11,'O',sp,(6+1); reg:addr
	ld2 R10,'O',sp,(6+1) ;reg:INDIRI2(addr)
	str1 R10,R11; ASGNU1(indaddr,LOADU1(LOADU2(reg))) 18-03-21
;void putx(unsigned char x){ //print a unsigned char as ascii hex
;	putxn(x>>4);
	ld1 R11,'O',sp,(6+1)
	zExt R11 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
	shrI2I R11,4
	cpy1 R12,R11
	zExt R12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
	Ccall _putxn
;	putxn(x & 0x0F);
	ld1 R11,'O',sp,(6+1)
	zExt R11 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
	alu2I R11,R11,15,ani,ani
	;removed ?	cpy2 R11,R11
	cpy1 R12,R11
	zExt R12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
	Ccall _putxn
;}
L97:
	release 4
	Cretn

;$$function_end$$ _putx
;$$function_start$$:_printf=void function(pointer to char,...)
_printf:		;framesize=18
	reserve 8; save room for local variables
	pushr R6
	pushr R7
	reserve 4; save room for outgoing arguments
	st2 R12,'O',sp,(18+1); flag1 
	st2 R13,'O',sp,(20+1); flag2
;void printf(char *pptr,...){ //limited implementation of printf
;	register char* ptr=pptr; //try to save on loads/spills
	ld2 R7,'O',sp,(18+1) ;reg:INDIRP2(addr)
;	int argslot=0;	//used to align longs
	st2I 0,'O',sp,(12+1); ASGNI2(addr,acon)
;	int * this=(int *)&pptr;
	ldA2 R11,'O',sp,(18+1); reg:addr
	st2 R11,'O',sp,(14+1); ASGNP2(addr,reg)
;	this++; argslot++; //advance argument pointer and slot #
	ld2 R11,'O',sp,(14+1) ;reg:INDIRP2(addr)
	incm R11,2
	st2 R11,'O',sp,(14+1); ASGNP2(addr,reg)
	ld2 R11,'O',sp,(12+1) ;reg:INDIRI2(addr)
	incm R11,1
	st2 R11,'O',sp,(12+1); ASGNI2(addr,reg)
	lbr L100
L99:
;    while(*ptr) {
;		c=*ptr; ptr++;
	ldn1 R6,R7;reg:  INDIRU1(indaddr)
	incm R7,1
;		if (c!='%'){
	jeqU1I R6,37,L102;EQI2(CVUI2(reg),con8bit)**
;			putc(c);
	cpy1 R12,R6
	zExt R12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
	Ccall _putc
;			asm(" nop1806\n nop1806\n nop1806\n"); //17-03-13
 nop1806
 nop1806
 nop1806
;		} else{
	lbr L103
L102:
;			c=*ptr;ptr++;
	ldn1 R6,R7;reg:  INDIRU1(indaddr)
	incm R7,1
;			switch (c){
	cpy1 R11,R6
	zExt R11 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
	st2 R11,'O',sp,(9+1); ASGNI2(addr,reg)
	ld2 R11,'O',sp,(9+1) ;reg:INDIRI2(addr)
	ldaD R10,99; reg:acon
	jcI2 R11,R10,lbnf,L126; LT=lbnf i.e. subtract B from A and jump if borrow 
	jnI2I R11,108,lbnf,L127; GT reverse  the subtraction
	shl2I R11,1
	ld2 R11,'O',R11,(L128-198) ;reg:INDIRP2(addr)
	jumpv R11; JUMPV(reg)
	orgc
L128:
	dw L110
	dw L108
	dw L105
	dw L121
	dw L105
	dw L105
	dw L108
	dw L105
	dw L105
	dw L114
	orgc
L126:
	ld2 R11,'O',sp,(9+1) ;reg:INDIRI2(addr)
	jeqU2I R11,88,L113;EQI2(reg,con)
	lbr L105
L127:
	ld2 R11,'O',sp,(9+1) ;reg:INDIRI2(addr)
	ldaD R10,115; reg:acon
	jeqI2 R11,R10,L109; EQI2(reg,reg)
	jcI2 R11,R10,lbnf,L105; LT=lbnf i.e. subtract B from A and jump if borrow 
L130:
	ld2 R11,'O',sp,(9+1) ;reg:INDIRI2(addr)
	jeqU2I R11,120,L113;EQI2(reg,con)
	lbr L105
L108:
;					printint(*this++);
	ld2 R11,'O',sp,(14+1) ;reg:INDIRP2(addr)
	cpy2 R10,R11
	incm R10,2
	st2 R10,'O',sp,(14+1); ASGNP2(addr,reg)
	ld2 R12,'O',R11,0 ;reg:INDIRI2(addr)
	Ccall _printint
;					argslot+=1; //next argument slot
	ld2 R11,'O',sp,(12+1) ;reg:INDIRI2(addr)
	incm R11,1
	st2 R11,'O',sp,(12+1); ASGNI2(addr,reg)
;					break;
	lbr L106
L109:
;					printstr((char*) *this++);
	ld2 R11,'O',sp,(14+1) ;reg:INDIRP2(addr)
	cpy2 R10,R11
	incm R10,2
	st2 R10,'O',sp,(14+1); ASGNP2(addr,reg)
	ld2 R11,'O',R11,0 ;reg:INDIRI2(addr)
	cpy2 R12,R11 ;LOADP2(reg)
	Ccall _printstr
;					argslot+=1; //next argument slot
	ld2 R11,'O',sp,(12+1) ;reg:INDIRI2(addr)
	incm R11,1
	st2 R11,'O',sp,(12+1); ASGNI2(addr,reg)
;					break;
	lbr L106
L110:
;					if (*ptr=='x'){ //if there's an x
	ldn1 R11,R7;reg:  INDIRU1(indaddr)
	jneU1I R11,120,L111	; DH 4
;						ptr++; //skip over the x
	incm R7,1
;						putx(((unsigned int) *this++)&255); //print 1 byte as hex
	ld2 R11,'O',sp,(14+1) ;reg:INDIRP2(addr)
	cpy2 R10,R11
	incm R10,2
	st2 R10,'O',sp,(14+1); ASGNP2(addr,reg)
	ld2 R11,'O',R11,0 ;reg:INDIRI2(addr)
	alu2I R11,R11,255,ani,ani ;removed copy;BANDU2(reg,con)  
	cpy1 R12,R11
	zExt R12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
	Ccall _putx
;					} else{
	lbr L112
L111:
;						putc((unsigned int) *this++);		//print as char
	ld2 R11,'O',sp,(14+1) ;reg:INDIRP2(addr)
	cpy2 R10,R11
	incm R10,2
	st2 R10,'O',sp,(14+1); ASGNP2(addr,reg)
	ld2 R11,'O',R11,0 ;reg:INDIRI2(addr)
	cpy1 R12,R11
	zExt R12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
	Ccall _putc
;					}
L112:
;					argslot+=1; //next argument slot
	ld2 R11,'O',sp,(12+1) ;reg:INDIRI2(addr)
	incm R11,1
	st2 R11,'O',sp,(12+1); ASGNI2(addr,reg)
;					break;
	lbr L106
L113:
;					putx(((unsigned int) *this)>>8);
	ld2 R11,'O',sp,(14+1) ;reg:INDIRP2(addr)
	ld2 R11,'O',R11,0 ;reg:INDIRI2(addr)
	shrU2I R11,8
	cpy1 R12,R11
	zExt R12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
	Ccall _putx
;					putx(((unsigned int) *this++)&255);
	ld2 R11,'O',sp,(14+1) ;reg:INDIRP2(addr)
	cpy2 R10,R11
	incm R10,2
	st2 R10,'O',sp,(14+1); ASGNP2(addr,reg)
	ld2 R11,'O',R11,0 ;reg:INDIRI2(addr)
	alu2I R11,R11,255,ani,ani ;removed copy;BANDU2(reg,con)  
	cpy1 R12,R11
	zExt R12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
	Ccall _putx
;					argslot+=1; //next argument slot
	ld2 R11,'O',sp,(12+1) ;reg:INDIRI2(addr)
	incm R11,1
	st2 R11,'O',sp,(12+1); ASGNI2(addr,reg)
;					break;
	lbr L106
L114:
;					if (*ptr){ //as long as there's something there
	ldn1 R11,R7;reg:  INDIRU1(indaddr)
	jzU1 R11,L115; EQ 0 - nopromo 20-05-12
;						xord=*ptr++;
	cpy2 R11,R7 ;LOADP2(reg)
	cpy2 R7,R11
	incm R7,1
	ldA2 R10,'O',sp,(11+1); reg:addr
	ldn1 R11,R11;reg:  INDIRU1(indaddr)
	str1 R11,R10; ASGNU1(indaddr,reg)		DH*
;						if (argslot&1) {
	ld2 R11,'O',sp,(12+1) ;reg:INDIRI2(addr)
	alu2I R11,R11,1,ani,ani
	;removed ?	cpy2 R11,R11
	jzU2 R11,L117; EQ I 0
;							this++;
	ld2 R11,'O',sp,(14+1) ;reg:INDIRP2(addr)
	incm R11,2
	st2 R11,'O',sp,(14+1); ASGNP2(addr,reg)
;							argslot++;
	ld2 R11,'O',sp,(12+1) ;reg:INDIRI2(addr)
	incm R11,1
	st2 R11,'O',sp,(12+1); ASGNI2(addr,reg)
;						}
L117:
;						if(xord=='d'){
	ld1 R11,'O',sp,(11+1)
	jneU1I R11,100,L119	; DH 4
;							printlint(*(long *)this);//treats "this" as a pointer to long
	ld2 R11,'O',sp,(14+1) ;reg:INDIRP2(addr)
	ld4 Rp1p2,'O',R11,0;reg:  INDIRI4(addr)
	Ccall _printlint
;							this+=2;				// and advances it 4 bytes
	ld2 R11,'O',sp,(14+1) ;reg:INDIRP2(addr)
	incm R11,4
	st2 R11,'O',sp,(14+1); ASGNP2(addr,reg)
;						} else{
	lbr L120
L119:
;							putx(((unsigned int) *this)>>8);
	ld2 R11,'O',sp,(14+1) ;reg:INDIRP2(addr)
	ld2 R11,'O',R11,0 ;reg:INDIRI2(addr)
	shrU2I R11,8
	cpy1 R12,R11
	zExt R12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
	Ccall _putx
;							putx(((unsigned int) *this++)&255);
	ld2 R11,'O',sp,(14+1) ;reg:INDIRP2(addr)
	cpy2 R10,R11
	incm R10,2
	st2 R10,'O',sp,(14+1); ASGNP2(addr,reg)
	ld2 R11,'O',R11,0 ;reg:INDIRI2(addr)
	alu2I R11,R11,255,ani,ani ;removed copy;BANDU2(reg,con)  
	cpy1 R12,R11
	zExt R12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
	Ccall _putx
;							putx(((unsigned int) *this)>>8);
	ld2 R11,'O',sp,(14+1) ;reg:INDIRP2(addr)
	ld2 R11,'O',R11,0 ;reg:INDIRI2(addr)
	shrU2I R11,8
	cpy1 R12,R11
	zExt R12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
	Ccall _putx
;							putx(((unsigned int) *this++)&255);
	ld2 R11,'O',sp,(14+1) ;reg:INDIRP2(addr)
	cpy2 R10,R11
	incm R10,2
	st2 R10,'O',sp,(14+1); ASGNP2(addr,reg)
	ld2 R11,'O',R11,0 ;reg:INDIRI2(addr)
	alu2I R11,R11,255,ani,ani ;removed copy;BANDU2(reg,con)  
	cpy1 R12,R11
	zExt R12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
	Ccall _putx
;						}
L120:
;						argslot+=2;
	ld2 R11,'O',sp,(12+1) ;reg:INDIRI2(addr)
	incm R11,2
	st2 R11,'O',sp,(12+1); ASGNI2(addr,reg)
;						break;
	lbr L106
L115:
L121:
;					if (*ptr){ //as long as there's something there
	ldn1 R11,R7;reg:  INDIRU1(indaddr)
	jzU1 R11,L122; EQ 0 - nopromo 20-05-12
;						if (argslot&1) { //adjust alignment
	ld2 R11,'O',sp,(12+1) ;reg:INDIRI2(addr)
	alu2I R11,R11,1,ani,ani
	;removed ?	cpy2 R11,R11
	jzU2 R11,L124; EQ I 0
;							this++;
	ld2 R11,'O',sp,(14+1) ;reg:INDIRP2(addr)
	incm R11,2
	st2 R11,'O',sp,(14+1); ASGNP2(addr,reg)
;							argslot++;
	ld2 R11,'O',sp,(12+1) ;reg:INDIRI2(addr)
	incm R11,1
	st2 R11,'O',sp,(12+1); ASGNI2(addr,reg)
;						}
L124:
;						printflt(*(float *)this);//treats "this" as a pointer to float
	ld2 R11,'O',sp,(14+1) ;reg:INDIRP2(addr)
	ld4 Rp1p2,'O',R11,0;INDIRF4(addr)
	Ccall _printflt
;						this+=2;				// and advances it 4 bytes
	ld2 R11,'O',sp,(14+1) ;reg:INDIRP2(addr)
	incm R11,4
	st2 R11,'O',sp,(14+1); ASGNP2(addr,reg)
;						argslot+=2;
	ld2 R11,'O',sp,(12+1) ;reg:INDIRI2(addr)
	incm R11,2
	st2 R11,'O',sp,(12+1); ASGNI2(addr,reg)
;						break;
	lbr L106
L122:
L105:
;					putc('%');putc(c);
	ldaD R12,37; reg:acon
	Ccall _putc
	cpy1 R12,R6
	zExt R12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
	Ccall _putc
;			} //switch
L106:
;		} //%
L103:
;	} //while
L100:
;    while(*ptr) {
	ldn1 R11,R7;reg:  INDIRU1(indaddr)
	jnzU1 R11,L99; NEI2(CVUI2(reg),con0)
;} //prtf
L98:
	release 4; release room for outgoing arguments
	popr R7
	popr R6
	release 8; release room for local variables 
	Cretn

;$$function_end$$ _printf
;$$function_start$$:_exit=void function(int)
_exit:		;framesize=6
	reserve 4
	st2 R12,'O',sp,(6+1); flag1 
;void exit(int code){
;	printf("exit %d\n",code);
	ldaD R12,L132; reg:acon
	ld2 R13,'O',sp,(6+1) ;reg:INDIRI2(addr)
	Ccall _printf
L133:
;	while(1);
L134:
	lbr L133
;}
L131:
	release 4
	Cretn

;$$function_end$$ _exit
;$$function_start$$:_memcmp=int function(pointer to const void,pointer to const void,unsigned int)
_memcmp:		;framesize=10
	reserve 4; save room for local variables
	pushr R6
	pushr R7
	ld2 R7,'O',sp,(14+1) ;reg:INDIRU2(addr)
;int memcmp(const void *Ptr1, const void *Ptr2, unsigned int Count){
;    int v = 0;
	ld2z R6; reg:con0
;    p1 = (unsigned char *)Ptr1;
	st2 R12,'O',sp,(6+1); ASGNP2(addr,reg)
;    p2 = (unsigned char *)Ptr2;
	st2 R13,'O',sp,(4+1); ASGNP2(addr,reg)
	lbr L138
L137:
;    while(Count-- > 0 && v == 0) {
;        v = *(p1++) - *(p2++);
	ld2 R11,'O',sp,(6+1) ;reg:INDIRP2(addr)
	cpy2 R10,R11
	incm R10,1
	st2 R10,'O',sp,(6+1); ASGNP2(addr,reg)
	ld2 R10,'O',sp,(4+1) ;reg:INDIRP2(addr)
	cpy2 R9,R10
	incm R9,1
	st2 R9,'O',sp,(4+1); ASGNP2(addr,reg)
	ldn1 R11,R11;reg:  INDIRU1(indaddr)
	zExt R11 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
	ldn1 R10,R10;reg:  INDIRU1(indaddr)
	zExt R10 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
	alu2 R6,R11,R10,sm,smb
;    }
L138:
;    while(Count-- > 0 && v == 0) {
	cpy2 R11,R7 ;LOADU2*(reg)
	cpy2 R7,R11	;SUBU2(reg,consm)
	decm R7,1	;SUBU2(reg,consm)
	jzU2 R11,L140; EQ U 0
	jzU2 R6,L137; EQ I 0
L140:
;    return v;
	cpy2 R15,R6 ;LOADI2(reg)
L136:
	popr R7
	popr R6
	release 4; release room for local variables 
	Cretn

;$$function_end$$ _memcmp
;$$function_start$$:_memcpy=pointer to void function(pointer to void,pointer to const void,unsigned int)
_memcpy:		;framesize=8
	reserve 2; save room for local variables
	pushr R6
	pushr R7
	ld2 R7,'O',sp,(12+1) ;reg:INDIRU2(addr)
;void* memcpy(void* dest, const void* src, unsigned int count) {
;        char* dst8 = (char*)dest;
	cpy2 R6,R12 ;LOADP2(reg)
;        char* src8 = (char*)src;
	st2 R13,'O',sp,(4+1); ASGNP2(addr,reg)
	lbr L143
L142:
;        while (count--) {
;            *dst8++ = *src8++;
	cpy2 R11,R6 ;LOADP2(reg)
	cpy2 R6,R11
	incm R6,1
	ld2 R10,'O',sp,(4+1) ;reg:INDIRP2(addr)
	cpy2 R9,R10
	incm R9,1
	st2 R9,'O',sp,(4+1); ASGNP2(addr,reg)
	ldn1 R10,R10;reg:  INDIRU1(indaddr)
	str1 R10,R11; ASGNU1(indaddr,reg)		DH*
;        }
L143:
;        while (count--) {
	cpy2 R11,R7 ;LOADU2*(reg)
	cpy2 R7,R11	;SUBU2(reg,consm)
	decm R7,1	;SUBU2(reg,consm)
	jnzU2 R11,L142; NE 0 
;        return dest;
	cpy2 R15,R12 ;LOADP2(reg)
L141:
	popr R7
	popr R6
	release 2; release room for local variables 
	Cretn

;$$function_end$$ _memcpy
;$$function_start$$:_memset=pointer to void function(pointer to void,int,unsigned int)
_memset:		;framesize=6
	pushr R6
	pushr R7
	ld2 R7,'O',sp,(10+1) ;reg:INDIRU2(addr)
;{
;    unsigned char* p=s;
	cpy2 R6,R12 ;LOADP2(reg)
	lbr L147
L146:
;    while(n){
;        *p = (unsigned char)c;
	str1 R13,R6; ASGNU1(indaddr,LOADU1(LOADU2(reg))) 18-03-21
;        p++;
	incm R6,1
;        n--;
	decm R7,1	;SUBU2(reg,consm)
;	}
L147:
;    while(n){
	jnzU2 R7,L146; NE 0 
;    return s;
	cpy2 R15,R12 ;LOADP2(reg)
L145:
	popr R7
	popr R6
	Cretn

;$$function_end$$ _memset
;$$function_start$$:_nstdlibincluder=void function(void)
_nstdlibincluder:		;framesize=2
;void nstdlibincluder(){
;	asm("\tinclude nstdlib.inc\n"); //strcpy, strcmp
	include nstdlib.inc
;}
L149:
	Cretn

;$$function_end$$ _nstdlibincluder
;$$function_start$$:_delay=void function(unsigned int)
_delay:		;framesize=10
	pushr R6
	pushr R7
	reserve 4; save room for outgoing arguments
	cpy2 R7,R12; function(2054) 1
;void delay(unsigned int howlong){
;	for (i=1;i!=howlong;i++){
	ldaD R6,1; reg:acon
	lbr L155
L152:
;		oneMs();
	Ccall _oneMs; CALLI2(ar)
;	}
L153:
;	for (i=1;i!=howlong;i++){
	incm R6,1
L155:
	jneU2 R6,R7,L152; NE
;}
L151:
	release 4; release room for outgoing arguments
	popr R7
	popr R6
	Cretn

;$$function_end$$ _delay
;$$function_start$$:_olduinoincluder=void function(void)
_olduinoincluder:		;framesize=2
;void olduinoincluder(){
;	asm("\tinclude olduino.inc\n");
	include olduino.inc
;}
L156:
	Cretn

;$$function_end$$ _olduinoincluder
	orgc
L132:
	db 101
	db 120
	db 105
	db 116
	db 32
	db 37
	db 100
	db 10
	db 0
	align 4
L67:
	dd 0xbf800000
	align 4
L66:
	dd 0x0
L22:
	db 79
	db 0
L13:
	db 32
	db 0
	include lcc1802epiloCX.inc
	include LCC1802fp.inc
	include IO1802.inc
	include LCC1802finale.inc
